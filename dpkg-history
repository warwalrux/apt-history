#!/usr/bin/env python3

import argparse
import json
import os
import pprint
import re
import shutil
import subprocess
import sys
import tabulate
import pprint
import yaml


TABLEFORMAT = "github"
DPKG_LOGFILE = "/var/log/dpkg.log"
ACTIONS = ['install', 'remove', 'upgrade', 'configure' ]
STYLED_ACTIONS = ['installed', 'removed', 'upgraded', 'configured' ]
OPPOSITES = { 'installed': 'remove', 'removed': 'install', 'upgraded': 'revert' }
STYLED_OPPOSITES = ['removed', 'installed', 'reverted'] 
STATUSES = [ "not-installed", "config-files", "half-installed", "unpacked", "half-configured", "triggers-awaited", "triggers-pending", "installed" ]
PP = pprint.PrettyPrinter(indent=4)

class pkgHandler():
    def __init__(self):
        self.commands = {
            'dpkg': shutil.which('dpkg'),
            'reconfigure': shutil.which('dpkg-reconfigure'),
            'apt': shutil.which('apt'),
        }

    def apt(self, args):
        # construct the command string
        # literally takes a list of arguments that are to be fed to apt.
        # _way_ less cool, but apt is currently not `-/--` argument based.
        runcmd = [self.commands['apt']]
        runcmd.extend(args)
        s = subprocess.Popen(runcmd, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
        print(s.communicate()[0].decode('utf8'))

    def run(self, data):
        # boilerplate logic to fold a dict into a list of bash appropriate arguments to supply to self.command.
        run_args_list = [ ['--' + key, conf[key]] for key in conf.keys() if key not in self.unacceptable_tags and conf[key] is not None and conf[key] is not True and conf[key] is not False ]
        run_args_flags = [ ['--' + key, conf[key]] for key in conf.keys() if key not in self.unacceptable_tags and conf[key] is True ]
        self.run_args = [ arg for args_pair in run_args_list for arg in args_pair ]
        self.run_flags = [ arg[0] for arg in run_args_flags ]

        # construct the command string
        runcmd = [self.commands['dpkg']]
        runcmd.extend(self.run_args)
        runcmd.extend(self.run_flags)

        # optionally if a precmd command is specified as a list we can run it and pipe the output to dpkg! neat!!!
        if "precmd" in conf.keys() and conf['precmd'] is not None:
            p = subprocess.Popen(conf['precmd'], stdout=subprocess.PIPE)
            s = subprocess.Popen(runcmd, stdin=p.stdout, stdout=subprocess.PIPE)
            print(s.communicate()[0].decode('utf8'))

        # otherwise just run the damned code.
        else:
            s = subprocess.Popen(runcmd, stdout=subprocess.PIPE)
            print(s.communicate()[0].decode('utf8'))

    def reconfigure(self, data):
        # boilerplate logic to fold a dict into a list of bash appropriate arguments to supply to self.command.
        run_args_list = [ ['--' + key, conf[key]] for key in conf.keys() if key not in self.unacceptable_tags and conf[key] is not None and conf[key] is not True and conf[key] is not False ]
        run_args_flags = [ ['--' + key, conf[key]] for key in conf.keys() if key not in self.unacceptable_tags and conf[key] is True ]
        self.run_args = [ arg for args_pair in run_args_list for arg in args_pair ]
        self.run_flags = [ arg[0] for arg in run_args_flags ]

        # construct the command string
        runcmd = [self.commands['reconfigure']]
        runcmd.extend(self.run_args)
        runcmd.extend(self.run_flags)

        # optionally if a precmd command is specified as a list we can run it and pipe the output to dpkg! neat!!!
        if "precmd" in conf.keys() and conf['precmd'] is not None:
            p = subprocess.Popen(conf['precmd'], stdout=subprocess.PIPE)
            s = subprocess.Popen(runcmd, stdin=p.stdout, stdout=subprocess.PIPE)
            print(s.communicate()[0].decode('utf8'))

        # otherwise just run the damned code.
        else:
            s = subprocess.Popen(runcmd, stdout=subprocess.PIPE)
            print(s.communicate()[0].decode('utf8'))

class History():
    def __init__(self):
        # Get yourself a dpkg handler, it's required for the undo / redo functionality later.
        self.PackageManager = pkgHandler()

        # Build a jobs object
        self.jobs = {}
        job_id = 1
        if os.path.isfile(DPKG_LOGFILE):
            history = {}
            with open(DPKG_LOGFILE, 'rb') as f:
                data = f.readlines()
            f.close()
            for record in data:
                record = record.decode('utf8').rstrip().split()
                
                # Ignore the seconds field in the time string
                record[1] = ':'.join([record[1].split(':')[0], record[1].split(':')[1]])
                if record[0] not in history.keys():
                    history[record[0]] = {}
                if record[1] not in history[record[0]].keys():
                    history[record[0]][record[1]] = []
                history[record[0]][record[1]].append(record[2:])

        for date in history.keys():
            for time in history[date].keys():
                self.jobs[job_id] = {}
                self.jobs[job_id]['date'] = date
                self.jobs[job_id]['time'] = time
                self.jobs[job_id]['data'] = []
                [[ self.jobs[job_id]['data'].append(line) for line in history[date][time] ]]
                job_id += 1
    
    def _print_table(self, table):
        # Use tabulate to fancy format output
        headers = table[0]
        table.pop(0)
        print(tabulate.tabulate(table, headers, tablefmt=TABLEFORMAT))


    def undoTransaction(self, data):
        for key in data.keys():
            if key in OPPOSITES.keys():
                # Remove table headers
                data[key].pop(0)
                if key == "installed":
                    [[ print(item[0] + " Version: " + item[1] + " is to be removed.") for item in data[key] ]]
                if key == "upgraded":
                    [[ print(item[0] + "version: " + item[2] + " will be replaced with: " + item[1]) for item in data[key] ]]
                if key == "removed":
                    [[ print(item[0] + " will be installed") for item in data[key] ]]

    def redoTransaction(self, data):
        for key in data.keys():
            data[key].pop(0)
            if key == "installed":
                [[ print(item[0] + " Version: " + item[1] + " is to be removed.") for item in data[key] ]]
            if key == "upgraded":
                [[ print(item[0] + "version: " + item[2] + " will be replaced with: " + item[1]) for item in data[key] ]]
            if key == "removed":
                [[ print(item[0] + " will be installed") for item in data[key] ]]


    def printJobs(self):
        output = [[ "Job ID", "Date", "Action", "Packages Affected" ]]
        for job in self.jobs:
            affected = []
            t = [ job, self.jobs[job]['date'], []]
            for line in self.jobs[job]['data']:
                if line[0] in ACTIONS and line[0] not in t[2]:
                    t[2].append(line[0])
                    if line[1] not in affected:
                        affected.append(line[1])
            t.append(len(affected))
            t[2] = ", ".join(t[2])
            output.append(t)
        self._print_table(output)


    def parseJobReport(self, job_id):
        info = self.jobs[int(job_id)]
        packages = []
        output = {}
        output['Job Id'] = job_id
        output['Date'] = info['date'] + " " + info['time']

        # Added headers for output table
        output['Status'] = [["Package Name", "Version", "Status"]]
        statuses = {}

        # Parse job from records
        for line in info['data']:
            if line[0] == "upgrade":
                if "upgraded" not in output.keys():
                    output['upgraded'] = [["Package Name", "Old Version", "New Version"]]
                output['upgraded'].append(line[1:4])
            if line[0] == "remove":
                if "removed" not in output.keys():
                    output['removed'] = [["Package Name", "Version"]]
                output['removed'].append(line[1:3])
            if line[0] == "configure":
                if "configured" not in output.keys():
                    output['configured'] = []
                output['configured'].append(line[1])
            if line[0] == "install":
                if "installed" not in output.keys():
                    output['installed'] = [["Package Name", "Version"]]
                output['installed'].append([line[1], line[3]])
            if line[0] == "status":
                statuses[line[2].split(':')[0]] = {}
                statuses[line[2].split(':')[0]]['Version'] = line[3]
                statuses[line[2].split(':')[0]]['Status'] = line[1]
        [[ output['Status'].append([key, statuses[key]['Version'], statuses[key]['Status']]) for key in statuses ]]

        # Include the raw object for inspection.
        output['raw'] = info
        return(output)

def main():
    history = History()
    parser = argparse.ArgumentParser()
    parser.add_argument('--debug', action="store_true", help="debug switch")
    action = parser.add_mutually_exclusive_group()
    action.add_argument('--list', action="store_true", help="Show dpkg transactions")
    action.add_argument('--info', help="Show transaction report by ID")
    action.add_argument('--inspect', help="Show detailed transaction data")
    action.add_argument('--redo', help="Redo transaction by ID")
    action.add_argument('--undo', help="Undo transaction by ID")
    action.add_argument('--find', help="search for transactions including the provided string")
    args = parser.parse_args()
    if args.list:
        history.printJobs()
    if args.info:
        output = history.parseJobReport(args.info)
        del output['raw']
        #del output['status']
        print("Job ID: " + output['Job Id'])
        print("Date and Time: " + output['Date'])
        del output['Date']
        del output['Job Id']

        for key in output.keys():
            print("\n"+key.capitalize()+":\n")
            if key != "configured":
                history._print_table(output[key])
            elif key == "configured":
               [[ print("  - " + line) for line in output[key] ]] 
        #print(yaml.dump(output, default_flow_style=False))

    if args.inspect:
        output = history.parseJobReport(args.inspect)
        print("Job ID: " + output['Job Id'])
        print("Date: " + output['Date'])
        [[ print(output['Date'], line) for line in output['raw']['data'] ]]

    if args.redo:
        data = history.parseJobReport(args.redo)
        history.redoTransaction(data)

    if args.undo:
        data = history.parseJobReport(args.undo)
        history.undoTransaction(data)

if __name__ == "__main__":
    main()
