#!/usr/bin/python3

import argparse
import datetime
import os
import pprint
import subprocess
import sys
import tabulate
import pprint

TABLEFORMAT = "github"
DPKG_LOGFILE = "/var/log/dpkg.log"
PACKAGE_HANDLER = "apt"
ACTIONS = ["install", "remove", "upgrade", "configure"]
STYLED_ACTIONS = ["installed", "removed", "upgraded", "configured"]
OPPOSITES = {"installed": "remove", "removed": "install", "upgraded": "revert"}
STYLED_OPPOSITES = ["removed", "installed", "reverted"]
PP = pprint.PrettyPrinter(indent=4)


class History:
    def __init__(self):
        # Build a jobs object
        self.jobs = {}
        statuses = {}
        job_id = 1
        if os.path.isfile(DPKG_LOGFILE):
            history = {}
            with open(DPKG_LOGFILE, "rb") as f:
                data = f.readlines()
            f.close()
        else:
            print("%s Not Found!" % (DPKG_LOGFILE))

        for record in data:
            record = record.decode("utf8").rstrip().split()
            # d is a string that can be converted to an epoch time string for evaluating start and end time for jobs.
            d = record[0].split("-") + record[1].split(":")
            
            # Ignore the seconds field in the time string
            record[1] = ":".join([record[1].split(":")[0], record[1].split(":")[1]])
            print(record[0].split("-"))
            if job_id not in self.jobs.keys():
                self.jobs[job_id] = {}
                self.jobs[job_id]["date"] = record[0]
                self.jobs[job_id]["time"] = record[1]
                self.jobs[job_id]["raw"] = []
                self.jobs[job_id]["data"] = {}

            elif (
                self.jobs[job_id]["date"] != record[0]
                or self.jobs[job_id]["time"] != record[1]
            ):
                self._stuffStatuses(job_id, statuses)
                statuses = {}
                job_id += 1
                self.jobs[job_id] = {}
                self.jobs[job_id]["date"] = record[0]
                self.jobs[job_id]["time"] = record[1]
                self.jobs[job_id]["raw"] = []
                self.jobs[job_id]["data"] = {}

            # Parse the line without the date and time fields
            line = record[2:]
            self.jobs[job_id]["raw"].append(line)
            if line[0] == "upgrade":
                if "upgraded" not in self.jobs[job_id]["data"].keys():
                    self.jobs[job_id]["data"]["upgraded"] = [
                        ["Package Name", "Old Version", "New Version"]
                    ]
                self.jobs[job_id]["data"]["upgraded"].append(line[1:4])
            if line[0] == "remove":
                if "removed" not in self.jobs[job_id]["data"].keys():
                    self.jobs[job_id]["data"]["removed"] = [["Package Name", "Version"]]
                self.jobs[job_id]["data"]["removed"].append(line[1:3])
            if line[0] == "configure":
                if "configured" not in self.jobs[job_id]["data"].keys():
                    self.jobs[job_id]["data"]["configured"] = []
                self.jobs[job_id]["data"]["configured"].append(line[1])
            if line[0] == "install":
                if "installed" not in self.jobs[job_id]["data"].keys():
                    self.jobs[job_id]["data"]["installed"] = [
                        ["Package Name", "Version"]
                    ]
                self.jobs[job_id]["data"]["installed"].append([line[1], line[3]])
            if line[0] == "status":
                if "status" not in self.jobs[job_id]["data"].keys():
                    self.jobs[job_id]["data"]["status"] = [
                        ["Package Name", "Version", "Status"]
                    ]
                if line[2].split(":")[0] not in statuses.keys():
                    statuses[line[2].split(":")[0]] = {}
                    statuses[line[2].split(":")[0]]["version"] = line[3]
                statuses[line[2].split(":")[0]]["status"] = line[1]

    def apt(self, args):
        if PACKAGE_HANDLER == "apt":
            # construct the command string
            # literally takes a list of arguments that are to be fed to apt.
            # _way_ less cool, but apt is currently not `-/--` argument based.
            runcmd = [self.commands["apt"]]
            runcmd.extend(args)
            s = subprocess.Popen(
                runcmd, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL
            )
            print(s.communicate()[0].decode("utf8"))

    def run(self, data):
        # boilerplate logic to fold a dict into a list of bash appropriate arguments to supply to self.command.
        run_args_list = [
            ["--" + key, conf[key]]
            for key in conf.keys()
            if key not in self.unacceptable_tags
            and conf[key] is not None
            and conf[key] is not True
            and conf[key] is not False
        ]
        run_args_flags = [
            ["--" + key, conf[key]]
            for key in conf.keys()
            if key not in self.unacceptable_tags and conf[key] is True
        ]
        self.run_args = [arg for args_pair in run_args_list for arg in args_pair]
        self.run_flags = [arg[0] for arg in run_args_flags]

        # construct the command string
        runcmd = [self.commands["dpkg"]]
        runcmd.extend(self.run_args)
        runcmd.extend(self.run_flags)

        # optionally if a precmd command is specified as a list we can run it and pipe the output to dpkg! neat!!!
        if "precmd" in conf.keys() and conf["precmd"] is not None:
            p = subprocess.Popen(conf["precmd"], stdout=subprocess.PIPE)
            s = subprocess.Popen(runcmd, stdin=p.stdout, stdout=subprocess.PIPE)
            print(s.communicate()[0].decode("utf8"))

        # otherwise just run the damned code.
        else:
            s = subprocess.Popen(runcmd, stdout=subprocess.PIPE)
            print(s.communicate()[0].decode("utf8"))

    def reconfigure(self, data):
        # boilerplate logic to fold a dict into a list of bash appropriate arguments to supply to self.command.
        run_args_list = [
            ["--" + key, conf[key]]
            for key in conf.keys()
            if key not in self.unacceptable_tags
            and conf[key] is not None
            and conf[key] is not True
            and conf[key] is not False
        ]
        run_args_flags = [
            ["--" + key, conf[key]]
            for key in conf.keys()
            if key not in self.unacceptable_tags and conf[key] is True
        ]
        self.run_args = [arg for args_pair in run_args_list for arg in args_pair]
        self.run_flags = [arg[0] for arg in run_args_flags]

        # construct the command string
        runcmd = [self.commands["reconfigure"]]
        runcmd.extend(self.run_args)
        runcmd.extend(self.run_flags)

        # optionally if a precmd command is specified as a list we can run it and pipe the output to dpkg! neat!!!
        if "precmd" in conf.keys() and conf["precmd"] is not None:
            p = subprocess.Popen(conf["precmd"], stdout=subprocess.PIPE)
            s = subprocess.Popen(runcmd, stdin=p.stdout, stdout=subprocess.PIPE)
            print(s.communicate()[0].decode("utf8"))

        # otherwise just run the damned code.
        else:
            s = subprocess.Popen(runcmd, stdout=subprocess.PIPE)
            print(s.communicate()[0].decode("utf8"))

    def _dumper(self):
        PP.pprint(self.jobs)

    def _stuffStatuses(self, job_id, status):
        [
            [
                self.jobs[job_id]["data"]["status"].append(
                    [key, status[key]["version"], status[key]["status"]]
                )
                for key in status.keys()
            ]
        ]

    def _print_table(self, table):
        # Use tabulate to fancy format output
        headers = table[0]
        table.pop(0)
        print(tabulate.tabulate(table, headers, tablefmt=TABLEFORMAT))

    def inspect(self, job_id):
        [[print(item) for item in self.jobs[int(job_id)]["raw"]]]

    def showJob(self, job_id):
        print("Job ID: %s" % (job_id))
        job_id = int(job_id)
        print("Date: %s" % (self.jobs[job_id]["date"]))
        print("Time: %s" % (self.jobs[job_id]["time"]))
        for key in self.jobs[job_id]["data"].keys():
            print("\n%s\n" % key.capitalize())
            if key in OPPOSITES.keys() or key == "status":
                self._print_table(self.jobs[job_id]["data"][key])
            elif key == "configured":
                [[print("  - %s" % item) for item in self.jobs[job_id]["data"][key]]]

    def redoJob(self, job_id):
        print(self.jobs[int(job_id)]["data"]["configured"])

    def listJobs(self):
        output = [["Job ID", "Date", "Action", "Packages Affected"]]
        for job_id in self.jobs:
            # Make a list for counting jobs
            affected = []
            for key in self.jobs[job_id]["data"].keys():
                # Look for only the stylized actions we care about (not status)
                if key in STYLED_ACTIONS:
                    # If the package isn't already in the affected list, put it in there
                    for row in self.jobs[job_id]["data"][key]:
                        if (
                            isinstance(row, list)
                            and row[0] != "Package Name"
                            and row[0].split(":")[0] not in affected
                        ):
                            affected.append(row[0].split(":")[0])
                        elif not isinstance(row, list):
                            affected.append(row)
            # Bundle up the output into a nice neat table row and add it to the list
            output.append(
                [
                    job_id,
                    self.jobs[job_id]["date"] + " " + self.jobs[job_id]["time"],
                    ", ".join(self.jobs[job_id]["data"].keys()),
                    len(affected),
                ]
            )
        self._print_table(output)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--debug", action="store_true", help="debug switch")
    action = parser.add_mutually_exclusive_group()
    action.add_argument("--list", action="store_true", help="Show dpkg transactions")
    action.add_argument("--info", help="Show transaction report by ID")
    action.add_argument("--inspect", help="Show detailed transaction data")
    action.add_argument("--redo", help="Redo transaction by ID")
    action.add_argument("--undo", help="Undo transaction by ID")
    action.add_argument(
        "--find", help="search for transactions including the provided string"
    )
    args = parser.parse_args()

    history = History()

    if args.list:
        history.listJobs()

    if args.info:
        history.showJob(args.info)

    if args.inspect:
        history.inspect(args.inspect)
    
    if args.redo:
        history.redoJob(args.redo)
    if args.debug:
        history._dumper()


if __name__ == "__main__":
    main()
