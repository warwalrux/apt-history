#!/usr/bin/python3

import argparse
import datetime
import gzip
import jinja2
import os
import pprint
import re
import shutil
import subprocess
import sys
import tabulate
import pprint

# SCRIPT CONFIGURABLES
# Output table format
TABLEFORMAT = "github"

# Define apt log location
DPKG_LOGDIR = "/var/log"
APT_LOGDIR = "/var/log/apt"

# Default package handler for undo-ing / redo-ing transactions
PACKAGE_HANDLER = "apt"

# Maximum duration in seconds between two lines of record and still being in the same job.
TIME_SENSITIVITY = 45

# Debugging tool 
PP = pprint.PrettyPrinter(indent=4)

# Some basic lingual definitions for logfile parsing
APT_ACTIONS = ["Install", "Remove", "Upgrade", "Purge"]
JANKY_KEYS = ["Start-Date", "End-Date", "Requested-By"]

class History:
    def __init__(self):
        # Build a jobs object based on apts history.log
        self.jobs = {}
        statuses = {}
        job_id = 0
        apt_data = self._find_sources(APT_LOGDIR, "history.log")
        for item in apt_data:
            item = item.decode('utf8').rstrip('\n')
            if item == "":
                job_id+=1
                self.jobs[job_id] = {}
                self.jobs[job_id]["actions"] = {}
                continue
            cur_key = item.split(":")[0]
            # Extra stupid space in date strings prevents datetime.datetime.fromisoformat() from working
            if cur_key in JANKY_KEYS and "Date" in cur_key:
                self.jobs[job_id][cur_key.lower().replace("-","_")] = item.replace(cur_key + ": ",'').replace("  ", " ")
            elif cur_key in JANKY_KEYS:
                self.jobs[job_id][cur_key.lower().replace("-","_")] = item.replace(cur_key + ": ",'')
            elif cur_key in APT_ACTIONS:
                if cur_key.lower() not in self.jobs[job_id]["actions"].keys():
                    affected = item.replace(cur_key + ": ", '').replace("(", ",").split("),")
                    self.jobs[job_id]["actions"][cur_key.lower()] = [ package.split(",") for package in affected]
            else:
                self.jobs[job_id][cur_key.lower()] = item.replace(cur_key + ": ",'')


    def _find_sources(self, location, fname):
        sources = []
        [ sources.append(logfile) if fname in logfile else "" for logfile in os.listdir(location) ]
        sources.sort(reverse=True)
        raw = []
        for source in sources:
            if source.split(".")[-1] == "gz":
                with gzip.open(os.path.join(location, source), "rb") as f:
                    [ raw.append(line) for line in f.readlines() ]
            else:
                with open(os.path.join(location, source), "rb") as f:
                    [ raw.append(line) for line in f.readlines() ]
        return(raw)

    def _print_table(self, table):
        # Use tabulate to fancy format output
        headers = table[0]
        table.pop(0)
        print(tabulate.tabulate(table, headers, tablefmt=TABLEFORMAT))

    def findPackage(self, package):
        data = {}
        for job in self.jobs:
            for action in self.jobs[job]["actions"].keys():
                for pkg in self.jobs[job]["actions"][action]:
                    if package in " ".join(pkg):
                        data[job] = self.jobs[job]
        PP.pprint(data)

    def listJobs(self, show_only):
        if show_only != "all":
            no_older = datetime.datetime.now() - datetime.timedelta(days = int(show_only))
        output = [["Job ID", "User", "Date", "Actions", "Altered" ]]
        for job_id in self.jobs.keys():
            job = self.jobs[job_id]
            altered = [len(job["actions"][action]) for action in job["actions"].keys()]
            if "requested_by" not in job.keys():
                job["requested_by"] = "system"
            row = [
                job_id,
                job["requested_by"],
                job["start_date"],
                ", ".join(job["actions"].keys()),
                sum(altered)
                
            ]
            # List size logic for show_last / show_all
            if show_only != "all" and datetime.datetime.fromisoformat(self.jobs[job_id]["start_date"]) > no_older:
                output.append(row)
            elif show_only == "all":
                output.append(row)
        self._print_table(output)


    def showJob(self, job_id):
        job = self.jobs[int(job_id)]
        if "requested_by" not in job.keys():
            job["requested_by"] = "system"
        string = """Job Id:\t\t{{ job_id }}
Start Date:\t{{ start_date }}
End Date:\t{{ end_date }}
User:\t\t{{ user }}
Invocation:\t{{ invocation }}
"""
        j = jinja2.Template(string)
        print(j.render(job_id=job_id,start_date=job["start_date"],end_date=job["end_date"],user=job["requested_by"],invocation=job["commandline"]))
        for action in job["actions"].keys():
            print(action.capitalize())
            for package in job["actions"][action]:
                print("  * " + package[0].lstrip())


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--debug", action="store_true", help="debug switch")
    show = parser.add_mutually_exclusive_group()
    show.add_argument("--show-last", help="Show last <num> days of transactions")
    show.add_argument("--show-all", action="store_true", help="Show last <num> days of transactions")
    action = parser.add_mutually_exclusive_group()
    action.add_argument("--list", action="store_true", help="Show dpkg transactions")
    action.add_argument("--info", help="Show transaction report by ID")
    action.add_argument("--redo", help="Redo transaction by ID")
    action.add_argument("--undo", help="Undo transaction by ID")
    action.add_argument(
        "--find", help="search for transactions including the provided string"
    )
    args = parser.parse_args()

    history = History()

    if args.list:
        show_only = 30
        if args.show_last:
            show_only = args.show_last
        if args.show_all:
            show_only = "all"
        history.listJobs(show_only)

    if args.info:
        history.showJob(args.info)
    
    if args.find:
        history.findPackage(args.find)
    if args.redo:
        history.redoJob(args.redo)

    if args.undo:
        history.undoJob(args.undo)

    if args.debug:
        print(args)

if __name__ == "__main__":
    main()
