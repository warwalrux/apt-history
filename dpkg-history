#!/usr/bin/python3

import argparse
import datetime
import gzip
import os
import pprint
import re
import shutil
import subprocess
import sys
import tabulate
import pprint

# SCRIPT CONFIGURABLES
# Output table format
TABLEFORMAT = "github"

# Define DPKG log location
DPKG_LOGDIR = "/var/log"
APT_LOGDIR = "/var/log/apt"

# Default package handler for undo-ing / redo-ing transactions
PACKAGE_HANDLER = "apt"

# Maximum duration in seconds between two lines of record and still being in the same job.
TIME_SENSITIVITY = 45

# Debugging tool 
PP = pprint.PrettyPrinter(indent=4)

# Some basic lingual definitions for logfile parsing
ACTIONS = ["install", "remove", "upgrade", "configure"]
STYLED_ACTIONS = ["installed", "removed", "upgraded", "configured"]
OPPOSITES = {"installed": "purge", "removed": ["install", "-y"], "upgraded": "revert"}
STYLED_OPPOSITES = ["removed", "installed", "reverted"]

class History:
    def __init__(self):
        # Build a jobs object based on apts history.log
        self.jobs = {}
        statuses = {}
        job_id = 0
        apt_data = self._find_sources(APT_LOGDIR, "history.log")
        self.dpkg_records = [[ record.decode("utf8").split() for record in self._find_sources(DPKG_LOGDIR, "dpkg.log") ]]
        for item in apt_data:
            item = item.decode('utf8').rstrip('\n')
            if item == "":
                job_id+=1
                self.jobs[job_id] = {}
                self.jobs[job_id]['data'] = []
                continue
            elif item.split(":")[0] == "Start-Date" or item.split(":")[0] == "End-Date":
                self.jobs[job_id][item.split(":")[0].lower().replace("-","_")] = item.replace(item.split(":")[0] + ": ",'').replace("  "," ")
            else:
                self.jobs[job_id][item.split(":")[0].lower()] = item.replace(item.split(":")[0] + ": ",'')
            self._interpolate_dpkg(job_id)
    def _interpolate_dpkg(self, job_id):
        print(job_id)
        print(self.jobs[job_id].keys())
        for record in self.dpkg_records:
            if record[0] == self.jobs[job_id]["start_date"].split()[0]:
                print(record)
#            # Parse the line without the date and time fields
#            line = record[2:]
#            self.jobs[job_id]["raw"].append([d_obj, line])
#            if line[0] == "upgrade":
#                if "upgraded" not in self.jobs[job_id]["data"].keys():
#                    self.jobs[job_id]["data"]["upgraded"] = [
#                        ["Package Name", "Old Version", "New Version"]
#                    ]
#                self.jobs[job_id]["data"]["upgraded"].append(line[1:4])
#            if line[0] == "remove":
#                if "removed" not in self.jobs[job_id]["data"].keys():
#                    self.jobs[job_id]["data"]["removed"] = [["Package Name", "Version"]]
#                self.jobs[job_id]["data"]["removed"].append(line[1:3])
#            if line[0] == "configure":
#                if "configured" not in self.jobs[job_id]["data"].keys():
#                    self.jobs[job_id]["data"]["configured"] = []
#                self.jobs[job_id]["data"]["configured"].append(line[1])
#            if line[0] == "install":
#                if "installed" not in self.jobs[job_id]["data"].keys():
#                    self.jobs[job_id]["data"]["installed"] = [
#                        ["Package Name", "Version"]
#                    ]
#                self.jobs[job_id]["data"]["installed"].append([line[1], line[3]])
#            if line[0] == "status":
#                if "status" not in self.jobs[job_id]["data"].keys():
#                    self.jobs[job_id]["data"]["status"] = [
#                        ["Package Name", "Version", "Status"]
#                    ]
#                if line[2].split(":")[0] not in statuses.keys():
#                    statuses[line[2].split(":")[0]] = {}
#                    statuses[line[2].split(":")[0]]["version"] = line[3]
#                statuses[line[2].split(":")[0]]["status"] = line[1]
#            d_last = d_obj
#        self.jobs[job_id]["date"]["end"] = d_last

    def _find_sources(self, location, fname):
        sources = []
        [ sources.append(logfile) if fname in logfile else "" for logfile in os.listdir(location) ]
        sources.sort(reverse=True)
        raw = []
        for source in sources:
            if source.split(".")[-1] == "gz":
                with gzip.open(os.path.join(location, source), "rb") as f:
                    [ raw.append(line) for line in f.readlines() ]
            else:
                with open(os.path.join(location, source), "rb") as f:
                    [ raw.append(line) for line in f.readlines() ]
        return(raw)

    def _stuffStatuses(self, job_id, status):
        [
            [
                self.jobs[job_id]["data"]["status"].append(
                    [key, status[key]["version"], status[key]["status"]]
                )
                for key in status.keys()
            ]
        ]

    def _print_table(self, table):
        # Use tabulate to fancy format output
        headers = table[0]
        table.pop(0)
        print(tabulate.tabulate(table, headers, tablefmt=TABLEFORMAT))

    def listJobs(self, show_only):
        if show_only != "all":
            no_older = datetime.datetime.now() - datetime.timedelta(days = int(show_only))

        output = [["Job ID", "Start", "Finish"]]
        for job_id in self.jobs.keys():
            print(self.jobs[job_id]["start_date"])
            # Make a list for counting jobs
#            for key in self.jobs[job_id]["data"].keys():
#                # Look for only the stylized actions we care about (not status)
#                if key in STYLED_ACTIONS:
#                    # If the package isn't already in the affected list, put it in there
#                    for row in self.jobs[job_id]["data"][key]:
#                        if (
#                            isinstance(row, list)
#                            and row[0] != "Package Name"
#                            and row[0].split(":")[0] not in affected
#                        ):
#                            affected.append(row[0].split(":")[0])
#                        elif not isinstance(row, list):
#                            affected.append(row)
#            # Bundle up the output into a nice neat table row and add it to the list
            row = [
                job_id,
                self.jobs[job_id]['start_date'],
                self.jobs[job_id]["end_date"],
            ]
#
            if show_only != "all" and datetime.datetime.fromisoformat(self.jobs[job_id]["start_date"]) > no_older:
                output.append(row)
            elif show_only == "all":
                output.append(row)
        self._print_table(output)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--debug", action="store_true", help="debug switch")
    show = parser.add_mutually_exclusive_group()
    show.add_argument("--show-last", help="Show last <num> days of transactions")
    show.add_argument("--show-all", action="store_true", help="Show last <num> days of transactions")
    action = parser.add_mutually_exclusive_group()
    action.add_argument("--list", action="store_true", help="Show dpkg transactions")
    action.add_argument("--info", help="Show transaction report by ID")
    action.add_argument("--inspect", help="Show detailed transaction data")
    action.add_argument("--redo", help="Redo transaction by ID")
    action.add_argument("--undo", help="Undo transaction by ID")
    action.add_argument(
        "--find", help="search for transactions including the provided string"
    )
    args = parser.parse_args()

    history = History()

    if args.list:
        show_only = 30
        if args.show_last:
            show_only = args.show_last
        if args.show_all:
            show_only = "all"
        history.listJobs(show_only)

    if args.info:
        history.showJob(args.info)

    if args.inspect:
        history.inspect(args.inspect)

    if args.redo:
        history.redoJob(args.redo)

    if args.undo:
        history.undoJob(args.undo)

    if args.debug:
        print(args)

if __name__ == "__main__":
    main()
